/* tslint:disable */
/* eslint-disable */
/**
 * ShapeShift
 * OpenAPI Schema for ShapeShift
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'detail': string;
}
/**
 * 
 * @export
 * @interface Exercise
 */
export interface Exercise {
    /**
     * 
     * @type {string}
     * @memberof Exercise
     */
    '_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Exercise
     */
    'exercise_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Exercise
     */
    'name': string;
    /**
     * 
     * @type {ExerciseType}
     * @memberof Exercise
     */
    'type'?: ExerciseType | null;
    /**
     * 
     * @type {string}
     * @memberof Exercise
     */
    'equipment'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Exercise
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Exercise
     */
    'muscle'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Exercise
     */
    'track_reps'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Exercise
     */
    'track_weight'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Exercise
     */
    'track_distance'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Exercise
     */
    'track_duration'?: boolean;
    /**
     * 
     * @type {Workout1}
     * @memberof Exercise
     */
    'workout': Workout1;
    /**
     * 
     * @type {Owner}
     * @memberof Exercise
     */
    'owner': Owner;
}


/**
 * 
 * @export
 * @interface Exercise1
 */
export interface Exercise1 {
    /**
     * 
     * @type {string}
     * @memberof Exercise1
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Exercise1
     */
    'collection': string;
}
/**
 * 
 * @export
 * @interface ExerciseCreate
 */
export interface ExerciseCreate {
    /**
     * 
     * @type {string}
     * @memberof ExerciseCreate
     */
    'name': string;
    /**
     * 
     * @type {ExerciseType}
     * @memberof ExerciseCreate
     */
    'type': ExerciseType;
    /**
     * 
     * @type {string}
     * @memberof ExerciseCreate
     */
    'muscle': string;
    /**
     * 
     * @type {string}
     * @memberof ExerciseCreate
     */
    'equipment': string;
    /**
     * 
     * @type {string}
     * @memberof ExerciseCreate
     */
    'description': string;
}


/**
 * 
 * @export
 * @interface ExerciseGPTData
 */
export interface ExerciseGPTData {
    /**
     * 
     * @type {string}
     * @memberof ExerciseGPTData
     */
    'workout_name': string;
    /**
     * 
     * @type {number}
     * @memberof ExerciseGPTData
     */
    'age': number;
    /**
     * 
     * @type {Gender}
     * @memberof ExerciseGPTData
     */
    'gender': Gender;
    /**
     * 
     * @type {number}
     * @memberof ExerciseGPTData
     */
    'weight': number;
    /**
     * 
     * @type {number}
     * @memberof ExerciseGPTData
     */
    'height': number;
    /**
     * 
     * @type {string}
     * @memberof ExerciseGPTData
     */
    'goal': string;
    /**
     * 
     * @type {string}
     * @memberof ExerciseGPTData
     */
    'experience': string;
    /**
     * 
     * @type {string}
     * @memberof ExerciseGPTData
     */
    'time': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExerciseGPTData
     */
    'target_muscle': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExerciseGPTData
     */
    'equipment': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExerciseGPTData
     */
    'exercise_type': Array<string>;
}


/**
 * 
 * @export
 * @interface ExerciseGPTOut
 */
export interface ExerciseGPTOut {
    /**
     * 
     * @type {string}
     * @memberof ExerciseGPTOut
     */
    'workout_name': string;
    /**
     * 
     * @type {string}
     * @memberof ExerciseGPTOut
     */
    'notes': string;
    /**
     * 
     * @type {Array<ExerciseCreate>}
     * @memberof ExerciseGPTOut
     */
    'exercises': Array<ExerciseCreate>;
}
/**
 * 
 * @export
 * @interface ExerciseInstance
 */
export interface ExerciseInstance {
    /**
     * 
     * @type {string}
     * @memberof ExerciseInstance
     */
    '_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExerciseInstance
     */
    'exercise_instance_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExerciseInstance
     */
    'sets'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof ExerciseInstance
     */
    'reps'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ExerciseInstance
     */
    'weight'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ExerciseInstance
     */
    'distance'?: Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExerciseInstance
     */
    'duration'?: Array<string>;
    /**
     * 
     * @type {Exercise1}
     * @memberof ExerciseInstance
     */
    'exercise': Exercise1;
    /**
     * 
     * @type {Session1}
     * @memberof ExerciseInstance
     */
    'session': Session1;
    /**
     * 
     * @type {Owner}
     * @memberof ExerciseInstance
     */
    'owner': Owner;
}
/**
 * 
 * @export
 * @interface ExerciseInstanceCreate
 */
export interface ExerciseInstanceCreate {
    /**
     * 
     * @type {string}
     * @memberof ExerciseInstanceCreate
     */
    'exercise_id': string;
}
/**
 * 
 * @export
 * @interface ExerciseInstanceOut
 */
export interface ExerciseInstanceOut {
    /**
     * 
     * @type {string}
     * @memberof ExerciseInstanceOut
     */
    'exercise_instance_id': string;
    /**
     * 
     * @type {number}
     * @memberof ExerciseInstanceOut
     */
    'sets': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof ExerciseInstanceOut
     */
    'reps': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ExerciseInstanceOut
     */
    'weight': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ExerciseInstanceOut
     */
    'distance': Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExerciseInstanceOut
     */
    'duration': Array<string>;
    /**
     * 
     * @type {Exercise}
     * @memberof ExerciseInstanceOut
     */
    'exercise': Exercise;
    /**
     * 
     * @type {Session}
     * @memberof ExerciseInstanceOut
     */
    'session': Session;
}
/**
 * 
 * @export
 * @interface ExerciseInstanceUpdate
 */
export interface ExerciseInstanceUpdate {
    /**
     * 
     * @type {number}
     * @memberof ExerciseInstanceUpdate
     */
    'sets': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof ExerciseInstanceUpdate
     */
    'reps': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ExerciseInstanceUpdate
     */
    'weight': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ExerciseInstanceUpdate
     */
    'distance': Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExerciseInstanceUpdate
     */
    'duration': Array<string>;
}
/**
 * 
 * @export
 * @interface ExerciseOut
 */
export interface ExerciseOut {
    /**
     * 
     * @type {string}
     * @memberof ExerciseOut
     */
    'exercise_id': string;
    /**
     * 
     * @type {string}
     * @memberof ExerciseOut
     */
    'name': string;
    /**
     * 
     * @type {ExerciseType}
     * @memberof ExerciseOut
     */
    'type': ExerciseType | null;
    /**
     * 
     * @type {string}
     * @memberof ExerciseOut
     */
    'muscle': string | null;
    /**
     * 
     * @type {string}
     * @memberof ExerciseOut
     */
    'equipment': string | null;
    /**
     * 
     * @type {string}
     * @memberof ExerciseOut
     */
    'description': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ExerciseOut
     */
    'track_reps': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ExerciseOut
     */
    'track_weight': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ExerciseOut
     */
    'track_distance': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ExerciseOut
     */
    'track_duration': boolean;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ExerciseType = {
    Cardio: 'cardio',
    Strength: 'strength',
    OlympicWeightlifting: 'olympic_weightlifting',
    Plyometrics: 'plyometrics',
    Powerlifting: 'powerlifting',
    Stretching: 'stretching',
    Strongman: 'strongman'
} as const;

export type ExerciseType = typeof ExerciseType[keyof typeof ExerciseType];


/**
 * 
 * @export
 * @interface ExerciseUpdate
 */
export interface ExerciseUpdate {
    /**
     * 
     * @type {string}
     * @memberof ExerciseUpdate
     */
    'name': string | null;
    /**
     * 
     * @type {ExerciseType}
     * @memberof ExerciseUpdate
     */
    'type': ExerciseType | null;
    /**
     * 
     * @type {string}
     * @memberof ExerciseUpdate
     */
    'muscle': string | null;
    /**
     * 
     * @type {string}
     * @memberof ExerciseUpdate
     */
    'equipment': string | null;
    /**
     * 
     * @type {string}
     * @memberof ExerciseUpdate
     */
    'description': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ExerciseUpdate
     */
    'track_reps': boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof ExerciseUpdate
     */
    'track_weight': boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof ExerciseUpdate
     */
    'track_distance': boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof ExerciseUpdate
     */
    'track_duration': boolean | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const Gender = {
    Male: 'male',
    Female: 'female',
    Other: 'other'
} as const;

export type Gender = typeof Gender[keyof typeof Gender];


/**
 * 
 * @export
 * @interface Goal
 */
export interface Goal {
    /**
     * 
     * @type {string}
     * @memberof Goal
     */
    '_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Goal
     */
    'goal_id'?: string;
    /**
     * 
     * @type {GoalType}
     * @memberof Goal
     */
    'category': GoalType;
    /**
     * 
     * @type {number}
     * @memberof Goal
     */
    'goal': number;
    /**
     * 
     * @type {TrackType}
     * @memberof Goal
     */
    'track_type'?: TrackType | null;
    /**
     * 
     * @type {string}
     * @memberof Goal
     */
    'exercise'?: string | null;
    /**
     * 
     * @type {Owner}
     * @memberof Goal
     */
    'owner': Owner;
}


/**
 * 
 * @export
 * @interface GoalCreate
 */
export interface GoalCreate {
    /**
     * 
     * @type {GoalType}
     * @memberof GoalCreate
     */
    'category': GoalType;
    /**
     * 
     * @type {number}
     * @memberof GoalCreate
     */
    'goal': number;
    /**
     * 
     * @type {TrackType}
     * @memberof GoalCreate
     */
    'track_type': TrackType | null;
    /**
     * 
     * @type {string}
     * @memberof GoalCreate
     */
    'exercise': string | null;
}


/**
 * 
 * @export
 * @interface GoalOut
 */
export interface GoalOut {
    /**
     * 
     * @type {string}
     * @memberof GoalOut
     */
    'goal_id': string;
    /**
     * 
     * @type {GoalType}
     * @memberof GoalOut
     */
    'category': GoalType;
    /**
     * 
     * @type {number}
     * @memberof GoalOut
     */
    'goal': number;
    /**
     * 
     * @type {TrackType}
     * @memberof GoalOut
     */
    'track_type': TrackType | null;
    /**
     * 
     * @type {string}
     * @memberof GoalOut
     */
    'exercise': string | null;
    /**
     * 
     * @type {UserOut}
     * @memberof GoalOut
     */
    'owner': UserOut;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const GoalType = {
    Weight: 'weight',
    Pr: 'pr',
    Completed: 'completed'
} as const;

export type GoalType = typeof GoalType[keyof typeof GoalType];


/**
 * 
 * @export
 * @interface GoalUpdate
 */
export interface GoalUpdate {
    /**
     * 
     * @type {GoalType}
     * @memberof GoalUpdate
     */
    'category': GoalType | null;
    /**
     * 
     * @type {number}
     * @memberof GoalUpdate
     */
    'goal': number | null;
    /**
     * 
     * @type {string}
     * @memberof GoalUpdate
     */
    'exercise': string | null;
}


/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface Owner
 */
export interface Owner {
    /**
     * 
     * @type {string}
     * @memberof Owner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Owner
     */
    'collection': string;
}
/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    '_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'session_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'date'?: string;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    'duration_mins'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof Session
     */
    'active'?: boolean;
    /**
     * 
     * @type {Workout1}
     * @memberof Session
     */
    'workout': Workout1;
    /**
     * 
     * @type {Owner}
     * @memberof Session
     */
    'owner': Owner;
}
/**
 * 
 * @export
 * @interface Session1
 */
export interface Session1 {
    /**
     * 
     * @type {string}
     * @memberof Session1
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Session1
     */
    'collection': string;
}
/**
 * 
 * @export
 * @interface SessionCreate
 */
export interface SessionCreate {
    /**
     * 
     * @type {string}
     * @memberof SessionCreate
     */
    'date': string;
    /**
     * 
     * @type {boolean}
     * @memberof SessionCreate
     */
    'active': boolean;
}
/**
 * 
 * @export
 * @interface SessionOut
 */
export interface SessionOut {
    /**
     * 
     * @type {string}
     * @memberof SessionOut
     */
    'session_id': string;
    /**
     * 
     * @type {string}
     * @memberof SessionOut
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof SessionOut
     */
    'duration_mins': number | null;
    /**
     * 
     * @type {boolean}
     * @memberof SessionOut
     */
    'active': boolean;
    /**
     * 
     * @type {Workout}
     * @memberof SessionOut
     */
    'workout': Workout;
}
/**
 * 
 * @export
 * @interface SessionUpdate
 */
export interface SessionUpdate {
    /**
     * 
     * @type {number}
     * @memberof SessionUpdate
     */
    'duration_mins': number | null;
    /**
     * 
     * @type {boolean}
     * @memberof SessionUpdate
     */
    'active': boolean;
}
/**
 * 
 * @export
 * @interface SessionWorkoutOut
 */
export interface SessionWorkoutOut {
    /**
     * 
     * @type {string}
     * @memberof SessionWorkoutOut
     */
    'session_id': string;
    /**
     * 
     * @type {string}
     * @memberof SessionWorkoutOut
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof SessionWorkoutOut
     */
    'duration_mins': number | null;
    /**
     * 
     * @type {boolean}
     * @memberof SessionWorkoutOut
     */
    'active': boolean;
}
/**
 * 
 * @export
 * @interface TokenSchema
 */
export interface TokenSchema {
    /**
     * 
     * @type {string}
     * @memberof TokenSchema
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof TokenSchema
     */
    'refresh_token': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TrackType = {
    Reps: 'reps',
    Weight: 'weight',
    Distance: 'distance',
    Duration: 'duration'
} as const;

export type TrackType = typeof TrackType[keyof typeof TrackType];


/**
 * 
 * @export
 * @interface UserAuth
 */
export interface UserAuth {
    /**
     * user email
     * @type {string}
     * @memberof UserAuth
     */
    'email': string;
    /**
     * user username
     * @type {string}
     * @memberof UserAuth
     */
    'username': string;
    /**
     * user password
     * @type {string}
     * @memberof UserAuth
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface UserOut
 */
export interface UserOut {
    /**
     * 
     * @type {string}
     * @memberof UserOut
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof UserOut
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserOut
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserOut
     */
    'first_name': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserOut
     */
    'last_name': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserOut
     */
    'birth_date': string | null;
    /**
     * 
     * @type {Gender}
     * @memberof UserOut
     */
    'gender': Gender | null;
    /**
     * 
     * @type {number}
     * @memberof UserOut
     */
    'height_in': number | null;
    /**
     * 
     * @type {number}
     * @memberof UserOut
     */
    'weight': number | null;
}


/**
 * 
 * @export
 * @interface UserUpdate
 */
export interface UserUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'email': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'first_name': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'last_name': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'birth_date': string | null;
    /**
     * 
     * @type {Gender}
     * @memberof UserUpdate
     */
    'gender': Gender | null;
    /**
     * 
     * @type {number}
     * @memberof UserUpdate
     */
    'height_in': number | null;
    /**
     * 
     * @type {number}
     * @memberof UserUpdate
     */
    'weight': number | null;
}


/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}
/**
 * 
 * @export
 * @interface Workout
 */
export interface Workout {
    /**
     * 
     * @type {string}
     * @memberof Workout
     */
    '_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Workout
     */
    'workout_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Workout
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Workout
     */
    'created_date'?: string;
    /**
     * 
     * @type {number}
     * @memberof Workout
     */
    'duration_mins'?: number | null;
    /**
     * 
     * @type {Array<number>}
     * @memberof Workout
     */
    'day_of_week'?: Array<number>;
    /**
     * 
     * @type {Owner}
     * @memberof Workout
     */
    'owner': Owner;
}
/**
 * 
 * @export
 * @interface Workout1
 */
export interface Workout1 {
    /**
     * 
     * @type {string}
     * @memberof Workout1
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Workout1
     */
    'collection': string;
}
/**
 * 
 * @export
 * @interface WorkoutCreate
 */
export interface WorkoutCreate {
    /**
     * 
     * @type {string}
     * @memberof WorkoutCreate
     */
    'title': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof WorkoutCreate
     */
    'day_of_week'?: Array<number>;
}
/**
 * 
 * @export
 * @interface WorkoutOut
 */
export interface WorkoutOut {
    /**
     * 
     * @type {string}
     * @memberof WorkoutOut
     */
    'workout_id': string;
    /**
     * 
     * @type {string}
     * @memberof WorkoutOut
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof WorkoutOut
     */
    'created_date': string;
    /**
     * 
     * @type {number}
     * @memberof WorkoutOut
     */
    'duration_mins': number | null;
    /**
     * 
     * @type {Array<number>}
     * @memberof WorkoutOut
     */
    'day_of_week'?: Array<number>;
}
/**
 * 
 * @export
 * @interface WorkoutUpdate
 */
export interface WorkoutUpdate {
    /**
     * 
     * @type {string}
     * @memberof WorkoutUpdate
     */
    'title': string | null;
    /**
     * 
     * @type {number}
     * @memberof WorkoutUpdate
     */
    'duration_mins': number | null;
    /**
     * 
     * @type {Array<number>}
     * @memberof WorkoutUpdate
     */
    'day_of_week'?: Array<number>;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create access and refresh tokens for user
         * @param {string} username 
         * @param {string} password 
         * @param {string | null} [grantType] 
         * @param {string} [scope] 
         * @param {string | null} [clientId] 
         * @param {string | null} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('login', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('login', 'password', password)
            const localVarPath = `/api/v1/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh token
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('refreshToken', 'body', body)
            const localVarPath = `/api/v1/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Test if the access token is valid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testToken: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/test-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create access and refresh tokens for user
         * @param {string} username 
         * @param {string} password 
         * @param {string | null} [grantType] 
         * @param {string} [scope] 
         * @param {string | null} [clientId] 
         * @param {string | null} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(username, password, grantType, scope, clientId, clientSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Refresh token
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Test if the access token is valid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testToken(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testToken(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Create access and refresh tokens for user
         * @param {string} username 
         * @param {string} password 
         * @param {string | null} [grantType] 
         * @param {string} [scope] 
         * @param {string | null} [clientId] 
         * @param {string | null} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options?: any): AxiosPromise<TokenSchema> {
            return localVarFp.login(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh token
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(body: string, options?: any): AxiosPromise<TokenSchema> {
            return localVarFp.refreshToken(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Test if the access token is valid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testToken(options?: any): AxiosPromise<UserOut> {
            return localVarFp.testToken(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Create access and refresh tokens for user
     * @param {string} username 
     * @param {string} password 
     * @param {string | null} [grantType] 
     * @param {string} [scope] 
     * @param {string | null} [clientId] 
     * @param {string | null} [clientSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).login(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh token
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public refreshToken(body: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).refreshToken(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Test if the access token is valid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public testToken(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).testToken(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExerciseInstancesApi - axios parameter creator
 * @export
 */
export const ExerciseInstancesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an exercise instance
         * @param {string} sessionId 
         * @param {ExerciseInstanceCreate} exerciseInstanceCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExerciseInstance: async (sessionId: string, exerciseInstanceCreate: ExerciseInstanceCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('createExerciseInstance', 'sessionId', sessionId)
            // verify required parameter 'exerciseInstanceCreate' is not null or undefined
            assertParamExists('createExerciseInstance', 'exerciseInstanceCreate', exerciseInstanceCreate)
            const localVarPath = `/api/v1/exercise-instance/{session_id}`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exerciseInstanceCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an exercise instance
         * @param {string} exerciseInstanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExerciseInstance: async (exerciseInstanceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exerciseInstanceId' is not null or undefined
            assertParamExists('deleteExerciseInstance', 'exerciseInstanceId', exerciseInstanceId)
            const localVarPath = `/api/v1/exercise-instance/{exercise_instance_id}`
                .replace(`{${"exercise_instance_id"}}`, encodeURIComponent(String(exerciseInstanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single exercise instance
         * @param {string} exerciseInstanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExerciseInstance: async (exerciseInstanceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exerciseInstanceId' is not null or undefined
            assertParamExists('getExerciseInstance', 'exerciseInstanceId', exerciseInstanceId)
            const localVarPath = `/api/v1/exercise-instance/{exercise_instance_id}`
                .replace(`{${"exercise_instance_id"}}`, encodeURIComponent(String(exerciseInstanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all exercise instances
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExerciseInstances: async (sessionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getExerciseInstances', 'sessionId', sessionId)
            const localVarPath = `/api/v1/exercise-instance/exercise-instances/{session_id}`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all exercise instances by exercise
         * @param {string} exerciseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExerciseInstancesByExercise: async (exerciseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exerciseId' is not null or undefined
            assertParamExists('getExerciseInstancesByExercise', 'exerciseId', exerciseId)
            const localVarPath = `/api/v1/exercise-instance/exercise-instances/exercise/{exercise_id}`
                .replace(`{${"exercise_id"}}`, encodeURIComponent(String(exerciseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an exercise instance
         * @param {string} exerciseInstanceId 
         * @param {ExerciseInstanceUpdate} exerciseInstanceUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExerciseInstance: async (exerciseInstanceId: string, exerciseInstanceUpdate: ExerciseInstanceUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exerciseInstanceId' is not null or undefined
            assertParamExists('updateExerciseInstance', 'exerciseInstanceId', exerciseInstanceId)
            // verify required parameter 'exerciseInstanceUpdate' is not null or undefined
            assertParamExists('updateExerciseInstance', 'exerciseInstanceUpdate', exerciseInstanceUpdate)
            const localVarPath = `/api/v1/exercise-instance/{exercise_instance_id}`
                .replace(`{${"exercise_instance_id"}}`, encodeURIComponent(String(exerciseInstanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exerciseInstanceUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExerciseInstancesApi - functional programming interface
 * @export
 */
export const ExerciseInstancesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExerciseInstancesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an exercise instance
         * @param {string} sessionId 
         * @param {ExerciseInstanceCreate} exerciseInstanceCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExerciseInstance(sessionId: string, exerciseInstanceCreate: ExerciseInstanceCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExerciseInstance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExerciseInstance(sessionId, exerciseInstanceCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an exercise instance
         * @param {string} exerciseInstanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteExerciseInstance(exerciseInstanceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteExerciseInstance(exerciseInstanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single exercise instance
         * @param {string} exerciseInstanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExerciseInstance(exerciseInstanceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExerciseInstanceOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExerciseInstance(exerciseInstanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all exercise instances
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExerciseInstances(sessionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExerciseInstanceOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExerciseInstances(sessionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all exercise instances by exercise
         * @param {string} exerciseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExerciseInstancesByExercise(exerciseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExerciseInstanceOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExerciseInstancesByExercise(exerciseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an exercise instance
         * @param {string} exerciseInstanceId 
         * @param {ExerciseInstanceUpdate} exerciseInstanceUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExerciseInstance(exerciseInstanceId: string, exerciseInstanceUpdate: ExerciseInstanceUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExerciseInstanceOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateExerciseInstance(exerciseInstanceId, exerciseInstanceUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExerciseInstancesApi - factory interface
 * @export
 */
export const ExerciseInstancesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExerciseInstancesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an exercise instance
         * @param {string} sessionId 
         * @param {ExerciseInstanceCreate} exerciseInstanceCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExerciseInstance(sessionId: string, exerciseInstanceCreate: ExerciseInstanceCreate, options?: any): AxiosPromise<ExerciseInstance> {
            return localVarFp.createExerciseInstance(sessionId, exerciseInstanceCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an exercise instance
         * @param {string} exerciseInstanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExerciseInstance(exerciseInstanceId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteExerciseInstance(exerciseInstanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single exercise instance
         * @param {string} exerciseInstanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExerciseInstance(exerciseInstanceId: string, options?: any): AxiosPromise<ExerciseInstanceOut> {
            return localVarFp.getExerciseInstance(exerciseInstanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all exercise instances
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExerciseInstances(sessionId: string, options?: any): AxiosPromise<Array<ExerciseInstanceOut>> {
            return localVarFp.getExerciseInstances(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all exercise instances by exercise
         * @param {string} exerciseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExerciseInstancesByExercise(exerciseId: string, options?: any): AxiosPromise<Array<ExerciseInstanceOut>> {
            return localVarFp.getExerciseInstancesByExercise(exerciseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an exercise instance
         * @param {string} exerciseInstanceId 
         * @param {ExerciseInstanceUpdate} exerciseInstanceUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExerciseInstance(exerciseInstanceId: string, exerciseInstanceUpdate: ExerciseInstanceUpdate, options?: any): AxiosPromise<ExerciseInstanceOut> {
            return localVarFp.updateExerciseInstance(exerciseInstanceId, exerciseInstanceUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExerciseInstancesApi - object-oriented interface
 * @export
 * @class ExerciseInstancesApi
 * @extends {BaseAPI}
 */
export class ExerciseInstancesApi extends BaseAPI {
    /**
     * 
     * @summary Create an exercise instance
     * @param {string} sessionId 
     * @param {ExerciseInstanceCreate} exerciseInstanceCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExerciseInstancesApi
     */
    public createExerciseInstance(sessionId: string, exerciseInstanceCreate: ExerciseInstanceCreate, options?: AxiosRequestConfig) {
        return ExerciseInstancesApiFp(this.configuration).createExerciseInstance(sessionId, exerciseInstanceCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an exercise instance
     * @param {string} exerciseInstanceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExerciseInstancesApi
     */
    public deleteExerciseInstance(exerciseInstanceId: string, options?: AxiosRequestConfig) {
        return ExerciseInstancesApiFp(this.configuration).deleteExerciseInstance(exerciseInstanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single exercise instance
     * @param {string} exerciseInstanceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExerciseInstancesApi
     */
    public getExerciseInstance(exerciseInstanceId: string, options?: AxiosRequestConfig) {
        return ExerciseInstancesApiFp(this.configuration).getExerciseInstance(exerciseInstanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all exercise instances
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExerciseInstancesApi
     */
    public getExerciseInstances(sessionId: string, options?: AxiosRequestConfig) {
        return ExerciseInstancesApiFp(this.configuration).getExerciseInstances(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all exercise instances by exercise
     * @param {string} exerciseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExerciseInstancesApi
     */
    public getExerciseInstancesByExercise(exerciseId: string, options?: AxiosRequestConfig) {
        return ExerciseInstancesApiFp(this.configuration).getExerciseInstancesByExercise(exerciseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an exercise instance
     * @param {string} exerciseInstanceId 
     * @param {ExerciseInstanceUpdate} exerciseInstanceUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExerciseInstancesApi
     */
    public updateExerciseInstance(exerciseInstanceId: string, exerciseInstanceUpdate: ExerciseInstanceUpdate, options?: AxiosRequestConfig) {
        return ExerciseInstancesApiFp(this.configuration).updateExerciseInstance(exerciseInstanceId, exerciseInstanceUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExercisesApi - axios parameter creator
 * @export
 */
export const ExercisesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an exercise
         * @param {string} workoutId 
         * @param {ExerciseCreate} exerciseCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExercise: async (workoutId: string, exerciseCreate: ExerciseCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workoutId' is not null or undefined
            assertParamExists('createExercise', 'workoutId', workoutId)
            // verify required parameter 'exerciseCreate' is not null or undefined
            assertParamExists('createExercise', 'exerciseCreate', exerciseCreate)
            const localVarPath = `/api/v1/exercise/{workout_id}`
                .replace(`{${"workout_id"}}`, encodeURIComponent(String(workoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exerciseCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an exercise
         * @param {string} exerciseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExercise: async (exerciseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exerciseId' is not null or undefined
            assertParamExists('deleteExercise', 'exerciseId', exerciseId)
            const localVarPath = `/api/v1/exercise/{exercise_id}`
                .replace(`{${"exercise_id"}}`, encodeURIComponent(String(exerciseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all exercises
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllExercises: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/exercise/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single exercise
         * @param {string} exerciseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExercise: async (exerciseId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exerciseId' is not null or undefined
            assertParamExists('getExercise', 'exerciseId', exerciseId)
            const localVarPath = `/api/v1/exercise/{exercise_id}`
                .replace(`{${"exercise_id"}}`, encodeURIComponent(String(exerciseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all exercises
         * @param {string} workoutId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExercises: async (workoutId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workoutId' is not null or undefined
            assertParamExists('getExercises', 'workoutId', workoutId)
            const localVarPath = `/api/v1/exercise/exercises/{workout_id}`
                .replace(`{${"workout_id"}}`, encodeURIComponent(String(workoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an exercise
         * @param {string} exerciseId 
         * @param {ExerciseUpdate} exerciseUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExercise: async (exerciseId: string, exerciseUpdate: ExerciseUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exerciseId' is not null or undefined
            assertParamExists('updateExercise', 'exerciseId', exerciseId)
            // verify required parameter 'exerciseUpdate' is not null or undefined
            assertParamExists('updateExercise', 'exerciseUpdate', exerciseUpdate)
            const localVarPath = `/api/v1/exercise/{exercise_id}`
                .replace(`{${"exercise_id"}}`, encodeURIComponent(String(exerciseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exerciseUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExercisesApi - functional programming interface
 * @export
 */
export const ExercisesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExercisesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an exercise
         * @param {string} workoutId 
         * @param {ExerciseCreate} exerciseCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExercise(workoutId: string, exerciseCreate: ExerciseCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Exercise>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExercise(workoutId, exerciseCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an exercise
         * @param {string} exerciseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteExercise(exerciseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteExercise(exerciseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all exercises
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllExercises(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExerciseOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllExercises(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single exercise
         * @param {string} exerciseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExercise(exerciseId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExerciseOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExercise(exerciseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all exercises
         * @param {string} workoutId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExercises(workoutId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExerciseOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExercises(workoutId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an exercise
         * @param {string} exerciseId 
         * @param {ExerciseUpdate} exerciseUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExercise(exerciseId: string, exerciseUpdate: ExerciseUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExerciseOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateExercise(exerciseId, exerciseUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExercisesApi - factory interface
 * @export
 */
export const ExercisesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExercisesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an exercise
         * @param {string} workoutId 
         * @param {ExerciseCreate} exerciseCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExercise(workoutId: string, exerciseCreate: ExerciseCreate, options?: any): AxiosPromise<Exercise> {
            return localVarFp.createExercise(workoutId, exerciseCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an exercise
         * @param {string} exerciseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExercise(exerciseId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteExercise(exerciseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all exercises
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllExercises(options?: any): AxiosPromise<Array<ExerciseOut>> {
            return localVarFp.getAllExercises(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single exercise
         * @param {string} exerciseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExercise(exerciseId: string, options?: any): AxiosPromise<ExerciseOut> {
            return localVarFp.getExercise(exerciseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all exercises
         * @param {string} workoutId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExercises(workoutId: string, options?: any): AxiosPromise<Array<ExerciseOut>> {
            return localVarFp.getExercises(workoutId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an exercise
         * @param {string} exerciseId 
         * @param {ExerciseUpdate} exerciseUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExercise(exerciseId: string, exerciseUpdate: ExerciseUpdate, options?: any): AxiosPromise<ExerciseOut> {
            return localVarFp.updateExercise(exerciseId, exerciseUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExercisesApi - object-oriented interface
 * @export
 * @class ExercisesApi
 * @extends {BaseAPI}
 */
export class ExercisesApi extends BaseAPI {
    /**
     * 
     * @summary Create an exercise
     * @param {string} workoutId 
     * @param {ExerciseCreate} exerciseCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExercisesApi
     */
    public createExercise(workoutId: string, exerciseCreate: ExerciseCreate, options?: AxiosRequestConfig) {
        return ExercisesApiFp(this.configuration).createExercise(workoutId, exerciseCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an exercise
     * @param {string} exerciseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExercisesApi
     */
    public deleteExercise(exerciseId: string, options?: AxiosRequestConfig) {
        return ExercisesApiFp(this.configuration).deleteExercise(exerciseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all exercises
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExercisesApi
     */
    public getAllExercises(options?: AxiosRequestConfig) {
        return ExercisesApiFp(this.configuration).getAllExercises(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single exercise
     * @param {string} exerciseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExercisesApi
     */
    public getExercise(exerciseId: string, options?: AxiosRequestConfig) {
        return ExercisesApiFp(this.configuration).getExercise(exerciseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all exercises
     * @param {string} workoutId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExercisesApi
     */
    public getExercises(workoutId: string, options?: AxiosRequestConfig) {
        return ExercisesApiFp(this.configuration).getExercises(workoutId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an exercise
     * @param {string} exerciseId 
     * @param {ExerciseUpdate} exerciseUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExercisesApi
     */
    public updateExercise(exerciseId: string, exerciseUpdate: ExerciseUpdate, options?: AxiosRequestConfig) {
        return ExercisesApiFp(this.configuration).updateExercise(exerciseId, exerciseUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GenerateApi - axios parameter creator
 * @export
 */
export const GenerateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Generate a workout plan
         * @param {ExerciseGPTData} exerciseGPTData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateWorkoutPlan: async (exerciseGPTData: ExerciseGPTData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exerciseGPTData' is not null or undefined
            assertParamExists('generateWorkoutPlan', 'exerciseGPTData', exerciseGPTData)
            const localVarPath = `/api/v1/generate/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exerciseGPTData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GenerateApi - functional programming interface
 * @export
 */
export const GenerateApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GenerateApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Generate a workout plan
         * @param {ExerciseGPTData} exerciseGPTData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateWorkoutPlan(exerciseGPTData: ExerciseGPTData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExerciseGPTOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateWorkoutPlan(exerciseGPTData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GenerateApi - factory interface
 * @export
 */
export const GenerateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GenerateApiFp(configuration)
    return {
        /**
         * 
         * @summary Generate a workout plan
         * @param {ExerciseGPTData} exerciseGPTData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateWorkoutPlan(exerciseGPTData: ExerciseGPTData, options?: any): AxiosPromise<ExerciseGPTOut> {
            return localVarFp.generateWorkoutPlan(exerciseGPTData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GenerateApi - object-oriented interface
 * @export
 * @class GenerateApi
 * @extends {BaseAPI}
 */
export class GenerateApi extends BaseAPI {
    /**
     * 
     * @summary Generate a workout plan
     * @param {ExerciseGPTData} exerciseGPTData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GenerateApi
     */
    public generateWorkoutPlan(exerciseGPTData: ExerciseGPTData, options?: AxiosRequestConfig) {
        return GenerateApiFp(this.configuration).generateWorkoutPlan(exerciseGPTData, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GoalsApi - axios parameter creator
 * @export
 */
export const GoalsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a goal
         * @param {GoalCreate} goalCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGoal: async (goalCreate: GoalCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'goalCreate' is not null or undefined
            assertParamExists('createGoal', 'goalCreate', goalCreate)
            const localVarPath = `/api/v1/goal/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(goalCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a goal
         * @param {string} goalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoal: async (goalId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'goalId' is not null or undefined
            assertParamExists('deleteGoal', 'goalId', goalId)
            const localVarPath = `/api/v1/goal/{goal_id}`
                .replace(`{${"goal_id"}}`, encodeURIComponent(String(goalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single goal
         * @param {string} goalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoal: async (goalId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'goalId' is not null or undefined
            assertParamExists('getGoal', 'goalId', goalId)
            const localVarPath = `/api/v1/goal/{goal_id}`
                .replace(`{${"goal_id"}}`, encodeURIComponent(String(goalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all goals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoals: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/goal/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a goal
         * @param {string} goalId 
         * @param {GoalUpdate} goalUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoals: async (goalId: string, goalUpdate: GoalUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'goalId' is not null or undefined
            assertParamExists('updateGoals', 'goalId', goalId)
            // verify required parameter 'goalUpdate' is not null or undefined
            assertParamExists('updateGoals', 'goalUpdate', goalUpdate)
            const localVarPath = `/api/v1/goal/{goal_id}`
                .replace(`{${"goal_id"}}`, encodeURIComponent(String(goalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(goalUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GoalsApi - functional programming interface
 * @export
 */
export const GoalsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GoalsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a goal
         * @param {GoalCreate} goalCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGoal(goalCreate: GoalCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Goal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGoal(goalCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a goal
         * @param {string} goalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGoal(goalId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGoal(goalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single goal
         * @param {string} goalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGoal(goalId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoalOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGoal(goalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all goals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGoals(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GoalOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGoals(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a goal
         * @param {string} goalId 
         * @param {GoalUpdate} goalUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGoals(goalId: string, goalUpdate: GoalUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoalOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGoals(goalId, goalUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GoalsApi - factory interface
 * @export
 */
export const GoalsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GoalsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a goal
         * @param {GoalCreate} goalCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGoal(goalCreate: GoalCreate, options?: any): AxiosPromise<Goal> {
            return localVarFp.createGoal(goalCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a goal
         * @param {string} goalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoal(goalId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGoal(goalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single goal
         * @param {string} goalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoal(goalId: string, options?: any): AxiosPromise<GoalOut> {
            return localVarFp.getGoal(goalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all goals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoals(options?: any): AxiosPromise<Array<GoalOut>> {
            return localVarFp.getGoals(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a goal
         * @param {string} goalId 
         * @param {GoalUpdate} goalUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoals(goalId: string, goalUpdate: GoalUpdate, options?: any): AxiosPromise<GoalOut> {
            return localVarFp.updateGoals(goalId, goalUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GoalsApi - object-oriented interface
 * @export
 * @class GoalsApi
 * @extends {BaseAPI}
 */
export class GoalsApi extends BaseAPI {
    /**
     * 
     * @summary Create a goal
     * @param {GoalCreate} goalCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public createGoal(goalCreate: GoalCreate, options?: AxiosRequestConfig) {
        return GoalsApiFp(this.configuration).createGoal(goalCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a goal
     * @param {string} goalId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public deleteGoal(goalId: string, options?: AxiosRequestConfig) {
        return GoalsApiFp(this.configuration).deleteGoal(goalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single goal
     * @param {string} goalId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public getGoal(goalId: string, options?: AxiosRequestConfig) {
        return GoalsApiFp(this.configuration).getGoal(goalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all goals
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public getGoals(options?: AxiosRequestConfig) {
        return GoalsApiFp(this.configuration).getGoals(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a goal
     * @param {string} goalId 
     * @param {GoalUpdate} goalUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalsApi
     */
    public updateGoals(goalId: string, goalUpdate: GoalUpdate, options?: AxiosRequestConfig) {
        return GoalsApiFp(this.configuration).updateGoals(goalId, goalUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PingApi - axios parameter creator
 * @export
 */
export const PingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PingApi - functional programming interface
 * @export
 */
export const PingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pingGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pingGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PingApi - factory interface
 * @export
 */
export const PingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PingApiFp(configuration)
    return {
        /**
         * 
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingGet(options?: any): AxiosPromise<void> {
            return localVarFp.pingGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PingApi - object-oriented interface
 * @export
 * @class PingApi
 * @extends {BaseAPI}
 */
export class PingApi extends BaseAPI {
    /**
     * 
     * @summary Ping
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PingApi
     */
    public pingGet(options?: AxiosRequestConfig) {
        return PingApiFp(this.configuration).pingGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SessionsApi - axios parameter creator
 * @export
 */
export const SessionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an session
         * @param {string} workoutId 
         * @param {SessionCreate} sessionCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSession: async (workoutId: string, sessionCreate: SessionCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workoutId' is not null or undefined
            assertParamExists('createSession', 'workoutId', workoutId)
            // verify required parameter 'sessionCreate' is not null or undefined
            assertParamExists('createSession', 'sessionCreate', sessionCreate)
            const localVarPath = `/api/v1/session/{workout_id}`
                .replace(`{${"workout_id"}}`, encodeURIComponent(String(workoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sessionCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSession: async (sessionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('deleteSession', 'sessionId', sessionId)
            const localVarPath = `/api/v1/session/{session_id}`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all active sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveSessions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/session/active/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession: async (sessionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('getSession', 'sessionId', sessionId)
            const localVarPath = `/api/v1/session/{session_id}`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/session/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all sessions for a workout
         * @param {string} workoutId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkoutSessions: async (workoutId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workoutId' is not null or undefined
            assertParamExists('getWorkoutSessions', 'workoutId', workoutId)
            const localVarPath = `/api/v1/session/workout/{workout_id}`
                .replace(`{${"workout_id"}}`, encodeURIComponent(String(workoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an session
         * @param {string} sessionId 
         * @param {SessionUpdate} sessionUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSession: async (sessionId: string, sessionUpdate: SessionUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('updateSession', 'sessionId', sessionId)
            // verify required parameter 'sessionUpdate' is not null or undefined
            assertParamExists('updateSession', 'sessionUpdate', sessionUpdate)
            const localVarPath = `/api/v1/session/{session_id}`
                .replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sessionUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionsApi - functional programming interface
 * @export
 */
export const SessionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an session
         * @param {string} workoutId 
         * @param {SessionCreate} sessionCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSession(workoutId: string, sessionCreate: SessionCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSession(workoutId, sessionCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSession(sessionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSession(sessionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all active sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveSessions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SessionOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveSessions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSession(sessionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSession(sessionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SessionOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all sessions for a workout
         * @param {string} workoutId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkoutSessions(workoutId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SessionWorkoutOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkoutSessions(workoutId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an session
         * @param {string} sessionId 
         * @param {SessionUpdate} sessionUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSession(sessionId: string, sessionUpdate: SessionUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSession(sessionId, sessionUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SessionsApi - factory interface
 * @export
 */
export const SessionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an session
         * @param {string} workoutId 
         * @param {SessionCreate} sessionCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSession(workoutId: string, sessionCreate: SessionCreate, options?: any): AxiosPromise<Session> {
            return localVarFp.createSession(workoutId, sessionCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSession(sessionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSession(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all active sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveSessions(options?: any): AxiosPromise<Array<SessionOut>> {
            return localVarFp.getActiveSessions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(sessionId: string, options?: any): AxiosPromise<SessionOut> {
            return localVarFp.getSession(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions(options?: any): AxiosPromise<Array<SessionOut>> {
            return localVarFp.getSessions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all sessions for a workout
         * @param {string} workoutId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkoutSessions(workoutId: string, options?: any): AxiosPromise<Array<SessionWorkoutOut>> {
            return localVarFp.getWorkoutSessions(workoutId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an session
         * @param {string} sessionId 
         * @param {SessionUpdate} sessionUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSession(sessionId: string, sessionUpdate: SessionUpdate, options?: any): AxiosPromise<SessionOut> {
            return localVarFp.updateSession(sessionId, sessionUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionsApi - object-oriented interface
 * @export
 * @class SessionsApi
 * @extends {BaseAPI}
 */
export class SessionsApi extends BaseAPI {
    /**
     * 
     * @summary Create an session
     * @param {string} workoutId 
     * @param {SessionCreate} sessionCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public createSession(workoutId: string, sessionCreate: SessionCreate, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).createSession(workoutId, sessionCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an session
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public deleteSession(sessionId: string, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).deleteSession(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all active sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getActiveSessions(options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getActiveSessions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single session
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getSession(sessionId: string, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getSession(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getSessions(options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getSessions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all sessions for a workout
     * @param {string} workoutId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getWorkoutSessions(workoutId: string, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getWorkoutSessions(workoutId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an session
     * @param {string} sessionId 
     * @param {SessionUpdate} sessionUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public updateSession(sessionId: string, sessionUpdate: SessionUpdate, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).updateSession(sessionId, sessionUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new user
         * @param {UserAuth} userAuth 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (userAuth: UserAuth, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userAuth' is not null or undefined
            assertParamExists('createUser', 'userAuth', userAuth)
            const localVarPath = `/api/v1/user/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userAuth, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCurrentUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update current user
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrentUser: async (userUpdate: UserUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userUpdate' is not null or undefined
            assertParamExists('updateCurrentUser', 'userUpdate', userUpdate)
            const localVarPath = `/api/v1/user/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new user
         * @param {UserAuth} userAuth 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(userAuth: UserAuth, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(userAuth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCurrentUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCurrentUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update current user
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCurrentUser(userUpdate: UserUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCurrentUser(userUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new user
         * @param {UserAuth} userAuth 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(userAuth: UserAuth, options?: any): AxiosPromise<UserOut> {
            return localVarFp.createUser(userAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCurrentUser(options?: any): AxiosPromise<void> {
            return localVarFp.deleteCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: any): AxiosPromise<UserOut> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update current user
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrentUser(userUpdate: UserUpdate, options?: any): AxiosPromise<UserOut> {
            return localVarFp.updateCurrentUser(userUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Create a new user
     * @param {UserAuth} userAuth 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(userAuth: UserAuth, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUser(userAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteCurrentUser(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getCurrentUser(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update current user
     * @param {UserUpdate} userUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateCurrentUser(userUpdate: UserUpdate, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateCurrentUser(userUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkoutsApi - axios parameter creator
 * @export
 */
export const WorkoutsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a workout
         * @param {WorkoutCreate} workoutCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkout: async (workoutCreate: WorkoutCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workoutCreate' is not null or undefined
            assertParamExists('createWorkout', 'workoutCreate', workoutCreate)
            const localVarPath = `/api/v1/workout/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workoutCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a workout
         * @param {string} workoutId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkout: async (workoutId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workoutId' is not null or undefined
            assertParamExists('deleteWorkout', 'workoutId', workoutId)
            const localVarPath = `/api/v1/workout/{workout_id}`
                .replace(`{${"workout_id"}}`, encodeURIComponent(String(workoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single workout
         * @param {string} workoutId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkout: async (workoutId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workoutId' is not null or undefined
            assertParamExists('getWorkout', 'workoutId', workoutId)
            const localVarPath = `/api/v1/workout/{workout_id}`
                .replace(`{${"workout_id"}}`, encodeURIComponent(String(workoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all workouts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkouts: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/workout/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a workout
         * @param {string} workoutId 
         * @param {WorkoutUpdate} workoutUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkout: async (workoutId: string, workoutUpdate: WorkoutUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workoutId' is not null or undefined
            assertParamExists('updateWorkout', 'workoutId', workoutId)
            // verify required parameter 'workoutUpdate' is not null or undefined
            assertParamExists('updateWorkout', 'workoutUpdate', workoutUpdate)
            const localVarPath = `/api/v1/workout/{workout_id}`
                .replace(`{${"workout_id"}}`, encodeURIComponent(String(workoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "JWT", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workoutUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkoutsApi - functional programming interface
 * @export
 */
export const WorkoutsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkoutsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a workout
         * @param {WorkoutCreate} workoutCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkout(workoutCreate: WorkoutCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workout>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkout(workoutCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a workout
         * @param {string} workoutId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkout(workoutId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkout(workoutId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single workout
         * @param {string} workoutId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkout(workoutId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkoutOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkout(workoutId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all workouts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkouts(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkoutOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkouts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a workout
         * @param {string} workoutId 
         * @param {WorkoutUpdate} workoutUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkout(workoutId: string, workoutUpdate: WorkoutUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkoutOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkout(workoutId, workoutUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkoutsApi - factory interface
 * @export
 */
export const WorkoutsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkoutsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a workout
         * @param {WorkoutCreate} workoutCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkout(workoutCreate: WorkoutCreate, options?: any): AxiosPromise<Workout> {
            return localVarFp.createWorkout(workoutCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a workout
         * @param {string} workoutId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkout(workoutId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWorkout(workoutId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single workout
         * @param {string} workoutId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkout(workoutId: string, options?: any): AxiosPromise<WorkoutOut> {
            return localVarFp.getWorkout(workoutId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all workouts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkouts(options?: any): AxiosPromise<Array<WorkoutOut>> {
            return localVarFp.getWorkouts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a workout
         * @param {string} workoutId 
         * @param {WorkoutUpdate} workoutUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkout(workoutId: string, workoutUpdate: WorkoutUpdate, options?: any): AxiosPromise<WorkoutOut> {
            return localVarFp.updateWorkout(workoutId, workoutUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkoutsApi - object-oriented interface
 * @export
 * @class WorkoutsApi
 * @extends {BaseAPI}
 */
export class WorkoutsApi extends BaseAPI {
    /**
     * 
     * @summary Create a workout
     * @param {WorkoutCreate} workoutCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkoutsApi
     */
    public createWorkout(workoutCreate: WorkoutCreate, options?: AxiosRequestConfig) {
        return WorkoutsApiFp(this.configuration).createWorkout(workoutCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a workout
     * @param {string} workoutId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkoutsApi
     */
    public deleteWorkout(workoutId: string, options?: AxiosRequestConfig) {
        return WorkoutsApiFp(this.configuration).deleteWorkout(workoutId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single workout
     * @param {string} workoutId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkoutsApi
     */
    public getWorkout(workoutId: string, options?: AxiosRequestConfig) {
        return WorkoutsApiFp(this.configuration).getWorkout(workoutId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all workouts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkoutsApi
     */
    public getWorkouts(options?: AxiosRequestConfig) {
        return WorkoutsApiFp(this.configuration).getWorkouts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a workout
     * @param {string} workoutId 
     * @param {WorkoutUpdate} workoutUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkoutsApi
     */
    public updateWorkout(workoutId: string, workoutUpdate: WorkoutUpdate, options?: AxiosRequestConfig) {
        return WorkoutsApiFp(this.configuration).updateWorkout(workoutId, workoutUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



